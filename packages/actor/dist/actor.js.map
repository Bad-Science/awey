{
  "version": 3,
  "sources": ["../actor.ts"],
  "sourcesContent": ["/**\n * @last: Towards ergonomic, parallel actor programming in YavaScript\n */\n\n\nimport { AsyncQueue } from './aq';\nimport { getEnvironmentData, setEnvironmentData, threadId } from 'worker_threads';\nimport { isMainThread } from 'worker_threads';\nimport { bottle, Bottle } from './bottlef';\nimport { IdentitySet } from './util';\n\n\n/*****************************************************************************/\n/** Messaging Types And Message Utility Types */\n/*****************************************************************************/\n\n// Utility Types\nexport type JSONPrimitive = string | number | boolean | null;\nexport type JSONValue = JSONPrimitive | JSONObject | JSONArray;\nexport type JSONObject = { [key: string]: JSONValue };\nexport type JSONArray = JSONValue[];\n\nexport type AnyMessage = JSONValue | SharedArrayBuffer;\nexport type AnyReturn = JSONValue | void;\n\nexport const DEFAULT_PREFIX = '_';\nexport type DEFAULT_PREFIX  = '_';\n\n// Exxtract handler function signature from actor and message key\nexport type Handler<A,H> = H extends keyof A \n  ? A[H] extends (...args: any[]) => void\n    ? A[H]\n    : never\n  : never;\n\nexport type MessageKeys<A extends Actor, PREFIX extends string> = {\n  [K in keyof A]: A[K] extends (...args: any) => any\n    ? K extends `${PREFIX}${infer M}`\n      ? M\n      : never\n    : never;\n}[keyof A]\n\n/*****************************************************************************/\n/** Actor Messaging */\n/*****************************************************************************/\n\n\n\n/*****************************************************************************/\n/** Actor Identity and Registration (Actor Realms) */\n/*****************************************************************************/\n\nexport type ActorId = number;\nexport type Pid<A> = {\n  localId: ActorId;\n  realmId: RealmId;\n  __actorType?: A;\n};\n\nexport type RealmId = number;\n\ntype GroupKey = string;\n\n// type ActorType<Type extends Actor> = (...args: any[]) => Type\n\ntype ActorTypeName = string;\n\ntype TypedActor<Type extends Actor> = {\n  type: ActorTypeName;\n  actor: Type;\n}\n\ntype TypedActorKey<T extends Actor> = {\n  type: ActorTypeName;\n  key: ActorKey;\n  __actorType?: T;\n}\n\ntype TypedGroupKey<T extends Actor> = {\n  type: ActorTypeName;\n  groupKey: GroupKey;\n  __actorType?: T;\n}\n\ntype ActorIdentifier<A extends Actor> = Pid<A> | TypedActorKey<A> | TypedGroupKey<A>;\n\n\ntype ForwardedMessage = {\n  type: 'message';\n  to: Pid<any>;\n  from?: Pid<any>;\n  key: string;\n  message: AnyMessage;\n  mid: string;\n}\n\ntype MessageResponse = {\n  type: 'reply';\n  to: Pid<any>;\n  from: Pid<any>;\n  mid: string;\n  reply: AnyReturn;\n}\n\n/**\n * IRC: Inter-Realm Communication\n */\ntype IRC = {\n  type: 'register';\n  pid: Pid<any>;\n  key: ActorKey;\n} | {\n  type: 'unregister';\n  key: ActorKey;\n} | {\n  type: 'registerGroup';\n  pid: Pid<any>;\n  groupKey: GroupKey;\n} | {\n  type: 'unregisterGroup';\n  pid: Pid<any>;\n  groupKey: GroupKey;\n} | ForwardedMessage | MessageResponse\n\n/**\n * A realm is the heart of the actor system. It tracks (\"allocates\") all local actors.\n * A realm tracks actors using weak references, so when no other references to an actor exist,\n * it is eligible for garbage collection.\n * \n * Generally, you should allocate one realm per thread in a multi-threaded actor system.\n * \n * REMINDER: an individual Realm is NOT thread safe.\n */\n\ntype ActorGroup = {\n  type: 'group';\n  key: GroupKey;\n  actors: Set<Pid<any>>;\n  lastAccess: number;\n}\n\ntype PidKey = `${Pid<any>['realmId']}:${Pid<any>['localId']}`;\n\nclass GroupMap {\n  private map = new Map<GroupKey, ActorGroup>();\n\n  put(key: GroupKey, pid: Pid<any>): void {\n    this.loadGroup(key).actors.add(pid);\n  }\n\n  get(key: GroupKey, scheme: SGroupScheme): Pid<any> | null {\n    return scheme(this.loadGroup(key));\n  }\n\n  getm(key: GroupKey, scheme: GroupScheme): Pid<any>[] {\n    const result = scheme(this.loadGroup(key));\n    if (!result) return [];\n    if (Array.isArray(result)) return result;\n    return [result];\n  }\n\n  delete(key: GroupKey, pid: Pid<any>): void {\n    this.loadGroup(key).actors.delete(pid);\n  }\n\n  private loadGroup(key: GroupKey): ActorGroup {\n    let group = this.map.get(key);\n    if (!group) {\n      group = { type: 'group', key, actors: new Set<Pid<any>>(), lastAccess: null };\n      this.map.set(key, group);\n    }\n    return group;\n  }\n\n  private keyFor(pid: Pid<any>): string {\n    return `${pid.realmId}:${pid.localId}`;\n  }\n}\n\n/*****************************************************************************/\n/** Group Access Schemes */\n/*****************************************************************************/\n\nexport type SGroupScheme = (group: ActorGroup) => Pid<any>;\nexport type MGroupScheme = (group: ActorGroup) => Pid<any>[];\nexport type GroupScheme = SGroupScheme | MGroupScheme;\n\nexport const RandomScheme: SGroupScheme = (group) => {\n  const index = Math.floor(Math.random() * group.actors.size);\n  return Array.from(group.actors)[index];\n}\n\nexport const RoundRobinScheme: SGroupScheme = (group) => {\n  const index = ++group.lastAccess % group.actors.size;\n  group.lastAccess = index;\n  return Array.from(group.actors)[index];\n}\n\nexport const BroadcastScheme: MGroupScheme = (group) => {\n  return Array.from(group.actors);\n}\n\nexport class ActorRealm {\n  public readonly realmId: RealmId;\n  private readonly crypto: Crypto;\n  private readonly actors: Map<ActorId, WeakRef<Actor>> = new Map();\n  private readonly localRegistry: Map<ActorKey, Pid<any>> = new Map();\n  private readonly registeredActors: Map<ActorId, TypedActor<any>> = new Map();\n  private readonly registeredGroups: GroupMap = new GroupMap();\n  private readonly ircChannel: StrictBroadcastChannel<IRC>;\n  //TODO: Per-realm irc channels for messaging\n  private nextActorId: ActorId = 1;\n  private awaitingReplies: Map<string, { resolve: (value: AnyReturn) => void, reject: (reason?: any) => void }> = new Map();\n  // private readonly mainState: {registry: Pid<Registry>} | null;\n\n  private static threadLocalInstance: ActorRealm;\n  static init(id: RealmId = threadId) {\n    if (this.threadLocalInstance) {\n      throw new Error('ActorRealm.initThreadLocal can only be called once per thread');\n    }\n    this.threadLocalInstance = new ActorRealm(id);\n  }\n\n  static get threadLocal() { return this.threadLocalInstance }\n\n  private constructor(id: RealmId) {\n    this.realmId = id;\n    this.crypto = new Crypto();\n\n    this.ircChannel = new StrictBroadcastChannel<IRC>(\"irc\");\n    this.ircChannel.onmessage = (event) => {\n      const update = event.data as IRC;\n      if (update.type === 'register') {\n        this.localRegistry.set(update.key, update.pid);\n      }\n      else if (update.type === 'registerGroup') {\n        this.registeredGroups.put(update.groupKey, update.pid);\n      }\n      else if (update.type === 'unregister') {\n        this.localRegistry.delete(update.key);\n      }\n      else if (update.type === 'unregisterGroup') {\n        this.registeredGroups.delete(update.groupKey, update.pid);\n      }\n      else if (update.type === 'message' && update.to.realmId == this.realmId) {\n        this.__receiveForwardedMessage(update);\n      }\n      else if (update.type === 'reply' && update.to.realmId == this.realmId) {\n        this.__receiveForwardedReply(update);\n      }\n    }\n  }\n\n  register(type: ActorTypeName, key: ActorKey, actor: Actor) {\n    this.registeredActors.set(actor.self.localId, { type, actor });\n    this.localRegistry.set(key, actor.self);\n    this.ircChannel.postMessage({ type: 'register', pid: actor.self, key });\n  }\n\n  // registerGroup(type: ActorTypeName, key: GroupKey, actors: Actor[]) {\n  //   let group = this.registeredGroups.get(key);\n  //   if (!group) {\n  //     group = new Set();\n  //     this.registeredGroups.set(key, group);\n  //   }\n  //   actors.forEach(a => {\n  //     group.add(a.self);\n  //     this.ircChannel.postMessage({ type: 'registerGroup', pid: a.self, groupKey: key });\n  //   });\n  // }\n\n\n  /**\n   * Allocate a pid for an actor and store a weak reference within the realm.\n   * @param actor - The actor to allocate a pid for.\n   * @returns The pid of the actor.\n   */\n  __allocate<Self extends Actor>(actor: Self): Pid<Self> {\n    const pid = this.createPid(actor);\n\n    this.actors.set(pid.localId, new WeakRef(actor));\n    return pid;\n  }\n\n  /**\n   * Lookup an actor by its pid.\n   * @param pid - The pid of the actor to lookup.\n   * @returns The actor if found, null if it has never existed recently, or undefined if it has been recently garbage collected.\n   */\n  __getLocal<Self extends Actor>(pid: Pid<Self>): Self | null | undefined {\n    const maybeActor = this.actors.get(pid.localId);\n    if (!maybeActor) return null;\n    return maybeActor.deref() as (Self | undefined);\n  }\n\n  __forwardMessage<Self extends Actor>(to: Pid<Self>, from: Pid<Self> | undefined, key: string, message: AnyMessage, { prefix }: { prefix?: string } = { prefix: DEFAULT_PREFIX as string }): Promise<AnyReturn> {\n    if (to.realmId == this.realmId) {\n      const actor = this.__getLocal(to);\n      if (!actor) throw new Error(`Actor ${to} not found in realm ${this.realmId}`);\n      return actor.__receive(key, message, { prefix }) as any;\n    }\n\n    return new Promise((resolve, reject) => {\n      const mid = this.crypto.randomUUID();\n      // if (from) {\n        this.awaitingReplies.set(mid, { resolve, reject });\n      // }\n      this.ircChannel.postMessage({ type: 'message', to, from, key, message, mid });      \n    })\n  }\n\n  async __receiveForwardedMessage(update: ForwardedMessage): Promise<void> {\n    if (update.to.realmId != this.realmId) return;\n    const maybeActor = this.actors.get(update.to.localId);\n    const actor = maybeActor?.deref();\n    if (!actor) return;\n    const reply = await actor.__receive(update.key, update.message, { prefix: DEFAULT_PREFIX })\n    if (update.from) {\n      this.ircChannel.postMessage({ type: 'reply', to: update.from, from: update.to, mid: update.mid, reply });\n    }\n  }\n\n  __receiveForwardedReply(update: MessageResponse): void {\n    const { resolve } = this.awaitingReplies.get(update.mid);\n    if (!resolve) {\n      console.error(`No resolver found for message id: ${update.mid}`);\n      return;\n    }\n    resolve(update.reply);\n    this.awaitingReplies.delete(update.mid);\n  }\n\n  lookup<Type extends Actor>(key: ActorKey): Pid<Type> | null {\n    return this.localRegistry.get(key) ?? null;\n  }\n\n  lookupGroups<Type extends Actor>(key: GroupKey, scheme: GroupScheme): Pid<Type>[] {\n    return this.registeredGroups.getm(key, scheme);\n  }\n\n  // async __register<Type extends Actor>(actorType: ActorTypeName, key: ActorKey, actor: Type): Promise<void> {\n  //   this.registeredActors.set(actor.self.localId, { type: actorType, actor });\n  //   try {\n  //     await Actor.send(this.registry, 'register', { pid: actor.self, key });\n  //   } catch (e) {\n  //     this.registeredActors.delete(actor.self.localId);\n  //     throw e;\n  //   }\n  // }\n\n    // async __findNamed<Type extends Actor>(type: ActorTypeName | null, key: ActorKey): Promise<Type | null> {\n  //   const pid = await this.__findNamedPid<any>(key);\n  //   if (!pid) return null;\n  //   const typedActor = this.registeredActors.get(pid.localId);\n  //   if (!typedActor) throw new Error('Actor is in registry but not in local realm');\n  //   const shouldTypeCheck = !!type;\n  //   if (shouldTypeCheck && typedActor.type !== type) throw new Error('Actor type mismatch');\n  //   return typedActor.actor;\n  // }\n\n  private createPid<Self extends Actor>(actor: Self): Pid<Self> {\n    return {\n      localId: this.nextActorId++,\n      realmId: this.realmId,\n      __actorType: void actor\n    }\n  }\n}\n\nfunction pid<A extends Actor>(actor: A): Pid<A> {\n  return {\n    localId: actor.self.localId,\n    realmId: actor.self.realmId,\n    __actorType: void actor\n  }\n}\n\n/*****************************************************************************/\n/** Actor Implementation with type-safe messaging */\n/*****************************************************************************/\n// explore decorators, add guards to ensure actors dont expose state, maybe use @on(key) decorators to define message handlers\n\n/**\n * Base Actor Class\n * \n * The Actor class is the base class for all actors. It provides a type-safe messaging interface.\n * Each Actor belongs to a realm, which stores a weak reference to the actor.\n * \n * Once an actor is no longer in use, it should be eligible for garbage collection.\n * \n * Some rules for actors:\n * \n * - Actors process one incoming message at a time using an async queue (per each actor).\n * - All messages are processed in the order they were received.\n * - All of the state an actor is responsible for must be stored within the actor class itself.\n * - Actors should never share state (without great care)\n * - Actors should be thought of primarily as units of concurrency or shared state, rather than code organization.\n * - Actor messages must be primitive types, or serializeable objects.\n * - Actors are fundamentally objects, and despite how much we love FP, we do not try to dance around that fact.\n * - If an actor becomes a bottleneck, it should be partitioned appropriately using a higher level actor.\n * \n * Messaging can also occur using the PubSub system, which uses BroadcastChannels to send messages to all actors\n * subscribed to a given topic. How type-safe PubSub should/needs to be is still being explored.\n * \n * On Concurrency / Parallelism:\n * The Actor system is designed to be used seamlessly in a multi-threaded or multi-process/cluster environment.\n * In the current state of ECMAScript, this presents a potential performance bottleneck, as most messages,\n * aside from SharedArrayBuffers, are deep cloned when sent between actors on different threads.\n * As-is, this is not a blocker for many applications, and is still very performant on a single thread,\n * but we are working with the assumption that the standards committee will adopt SharedStructs,\n * which will allow us to send messages between actors on different threads without cloning.\n * \n * At present, the only way to share memory between threads is through SharedArrayBuffers, and this can still\n * be very useful for performance critical applications, so we provide first-class support for them.\n */\n\n\nfunction isNamedActor<A extends Actor>(id: ActorIdentifier<A>): id is TypedActorKey<A> {\n  return typeof id === 'object' && 'type' in id && 'key' in id;\n}\n\nfunction isGroupKey<A extends Actor>(id: ActorIdentifier<A>): id is TypedGroupKey<A> {\n  return typeof id === 'object' && 'type' in id && 'groupKey' in id;\n}\n\nfunction isPid<A extends Actor>(id: ActorIdentifier<A>): id is Pid<A> {\n  return typeof id === 'object' && 'localId' in id && 'realmId' in id;\n}\n\nexport function send<\n  A extends Actor,\n  K extends MessageKeys<A, PREFIX>,\n  PREFIX extends string = DEFAULT_PREFIX,\n  H = `${PREFIX}${K}`,\n  P = Parameters<Handler<A, H>>[0],\n  R = ReturnType<Handler<A, H>>\n>(\n  to: ActorIdentifier<A>, \n  key: K,\n  message: P extends AnyMessage ? Parameters<Handler<A, H>>[0] : never,\n  { from, prefix, scheme }: { from?: Pid<any>, prefix?: PREFIX, scheme?: GroupScheme } = { prefix: DEFAULT_PREFIX as PREFIX, scheme: RandomScheme }\n): R extends Promise<AnyReturn> ? R : Promise<R extends AnyReturn ? ReturnType<Handler<A, H>> : never> {\n  const realm = ActorRealm.threadLocal;\n  let pid: Pid<A> | null = null;\n  if (isNamedActor(to)) {\n    pid = realm.lookup((to).key);\n  } else if (isGroupKey(to)) {\n    pid = realm.lookupGroups<any>((to).groupKey, scheme)[0];\n  } else if (isPid(to)) {\n    pid = to;\n  }\n\n  if (!pid) throw new Error(`Actor ${to} not found on realm ${realm.realmId}`);\n\n  if (pid.realmId != realm.realmId) {\n    return realm.__forwardMessage(pid, from, key, message, { prefix }) as any;\n  }\n\n  const actor = realm.__getLocal(pid);\n  if (!actor) throw new Error(`Actor ${pid} not found in realm ${realm.realmId}`);\n  return actor.__receive(key, message, { prefix }) as any;\n}\n\n// export function sendm<\n//   A extends Actor,\n//   K extends MessageKeys<A, PREFIX>,\n//   PREFIX extends string = DEFAULT_PREFIX,\n//   H = `${PREFIX}${K}`,\n//   P = Parameters<Handler<A, H>>[0],\n//   R = ReturnType<Handler<A, H>>\n// >(\n//   to: ActorIdentifier<A>[],\n//   key: K,\n//   message: P extends AnyMessage ? Parameters<Handler<A, H>>[0] : never,\n//   { from, prefix, scheme }: { from?: Pid<any>, prefix?: PREFIX, scheme?: GroupScheme } = { prefix: DEFAULT_PREFIX as PREFIX, scheme: BroadcastScheme }\n// ): R extends Promise<AnyReturn> ? R : Promise<R extends AnyReturn ? ReturnType<Handler<A, H>> : never> {\n//   const pids: Pid<A>[] = [];\n  \n//   return Promise.all(pids.map(pid => send(pid, key, message, { from, prefix })));\n// }\n\n\n\nexport class Actor {\n  declare readonly self: Pid<typeof this>;\n  private readonly mailbox: AsyncQueue;\n\n  constructor(protected readonly realm: ActorRealm = ActorRealm.threadLocal) {\n    this.mailbox = new AsyncQueue();\n    this.self = this.realm.__allocate(this);\n    const l = this.realm.__getLocal(this.self);\n    if (!l) {\n      throw new Error('failed to allocate self');\n    }\n    console.debug(`Allocated actor:${this.self.localId} in realm:${this.realm.realmId}`);\n  }\n\n  protected send<\n    A extends Actor,\n    K extends MessageKeys<A, PREFIX>,\n    PREFIX extends string = DEFAULT_PREFIX,\n    H = `${PREFIX}${K}`,\n    P = Parameters<Handler<A, H>>[0],\n    R = ReturnType<Handler<A, H>>\n  >(\n    pid: Pid<A> | TypedActorKey<A>,\n    key: K,\n    message: P extends AnyMessage ? Parameters<Handler<A, H>>[0] : never,\n    { prefix }: { prefix?: PREFIX } = { prefix: DEFAULT_PREFIX as PREFIX }\n  ): R extends Promise<AnyReturn> ? R : Promise<R extends AnyReturn ? ReturnType<Handler<A, H>> : never> {\n    console.log(`Sending message to actor ${pid} from ${this.self}`, { key, message });\n    return send(pid, key, message, { from: this.self, prefix });\n  }\n  \n  getSelf<Self extends Actor>(): Pid<Self> {\n    return this.self as unknown as Pid<Self>;\n  }\n\n  public pid<Self extends Actor>(): Pid<Self> {\n    return this.self as unknown as Pid<Self>;\n  }\n\n  _ping(message: string): 'pong' {\n    console.log('ping', message);\n    return 'pong';\n  }\n\n  async __receive(key: string, message: AnyMessage, { prefix }: { prefix: string }): Promise<AnyReturn> {\n    const handler = this[`${prefix}${key}`];\n    if (typeof handler === 'function') {\n      //TODO: Exceptions are bad. Convert to a {res, err} pattern\n      return this.mailbox.enqueue((m) => handler(m), [message]).catch(e => {\n        console.error('error handling message', key, 'on', this.self, e);\n        return Promise.reject(e);\n      });\n    }\n    else {\n      console.error('no handler for', key, 'on', this.self);\n      return Promise.reject(new Error('no handler for ' + key + ' on ' + this.self));\n    }\n  }\n}\n\n// TODO: Use string interpolated channel names to create typed, dynamically named channels.\nexport type TypedChannel<T> = {\n  type: T extends string ? T : never;\n}\n\nexport class StrictBroadcastChannel<\n  MessageType extends TypedChannel<any>,\n> extends BroadcastChannel {\n  public postMessage(message: MessageType): void {\n    return super.postMessage(message)\n  }\n}\n\n// export abstract class TypedActor<T extends Actor> extends Actor {\n//   declare self: Pid<T>;\n// }\n\n\n/*****************************************************************************/\n/** Actor registration and naming */\n/*****************************************************************************/\n\ntype ActorKey = string;\n// type ActorRegistration = {\n//   pid: Pid<any>;\n//   key: ActorKey;\n// }\nexport class DuplicateActorKeyError extends Error {\n  constructor(key: ActorKey, pid: Pid<any>) {\n    super(`Duplicate actor key: ${key} on pid: ${pid.localId}`);\n  }\n}\n\nexport class Registry extends Actor {\n  private pids: Map<ActorKey, Pid<any>> = new Map();\n\n  _register({pid, key}: {pid: Pid<any>, key: ActorKey}): void {\n    if (this.pids.has(key)) {\n      throw new DuplicateActorKeyError(key, pid);\n    }\n    this.pids.set(key, pid);\n  }\n\n  _find(key: ActorKey): Pid<any> | null {\n    return this.pids.get(key) ?? null;\n  }\n\n  _unregister(key: ActorKey): boolean {\n    return this.pids.delete(key);\n  }\n}\n\n/*****************************************************************************/\n/** Actor System */\n/*****************************************************************************/\n\n/**\n * \"If I'm this, then do that\" -- raya (and also our threading model)\n * \n * Somehow, it took me forever to come up with this nice way of defining threads.\n * YavaScript is really dumb when it comes to initializing threads, a thread's initial\n * behavior must be defined at compile time. To get around this, we define the starting\n * states of each actor thread in one file, and select the initialization function at runtime.\n * \n * I haven't seen anyone do this, but I think it's a nice way to deal with multithreaded js programs.\n */\nexport type ActorSystemDef = () => (() => Actor[])[];\ntype CoordinatorMessage = {\n  type: 'all_ready';\n} | {\n  type: 'worker_ready';\n  index: number;\n}\nexport function actorSystem(system: ActorSystemDef, systemFile: string, onInit: (id: RealmId) => void = () => {}) {\n  const realmDefs = system();\n  const coordinator = new StrictBroadcastChannel<CoordinatorMessage>('actor_system_coordinator');\n  \n  if (isMainThread) {\n    const readyMap = new Array<boolean>(realmDefs.length).fill(false);\n    coordinator.onmessage = ({data: {type, index}}) => {\n      if (realmDefs.length < 2) {\n        ActorRealm.init(0);\n        realmDefs[0]();\n        return;\n      }\n      if (type === 'worker_ready') {\n        readyMap[index] = true;\n        if (readyMap.every(Boolean)) {\n          console.log('all workers ready');\n          coordinator.postMessage({ type: 'all_ready' });\n          realmDefs[0]();\n        }\n      }\n    }\n    \n    ActorRealm.init(0);\n    readyMap[0] = true;\n\n    for (let index = 1; index < realmDefs.length; ++index) {\n      setEnvironmentData('ACTOR_SYSTEM_INDEX', index);\n      const worker = new Worker(systemFile);\n      worker.postMessage({ type: 'spawn', index });\n    }\n\n  } else {\n    const index = Number(getEnvironmentData('ACTOR_SYSTEM_INDEX'));\n    ActorRealm.init(index);\n\n    coordinator.onmessage = ({data: {type}}) => {\n      if (type === 'all_ready') {\n        if (!realmDefs[index]) {\n          throw new Error('spawner not defined');\n        } else {\n          realmDefs[index]();\n        }\n      }\n    }\n    coordinator.postMessage({ type: 'worker_ready', index });\n  }\n}\n\n/*****************************************************************************/\n/** Utility Functions */\n/*****************************************************************************/\n\nfunction ensurePromise<T>(value: T | Promise<T>): Promise<T> {\n  return value instanceof Promise ? value : Promise.resolve(value);\n}\n\nfunction isPrimitive(value: unknown): value is string | number | boolean | null | undefined | symbol | bigint {\n  const type = typeof value;\n  return value === null || type !== 'object' && type !== 'function';\n}\n"],
  "mappings": "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",
  "names": ["import_worker_threads", "pid"]
}

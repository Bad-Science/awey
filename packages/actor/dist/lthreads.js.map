{
  "version": 3,
  "sources": ["../lthreads.ts"],
  "sourcesContent": ["/*****************************************************************************/\n/** Actor System */\n/*****************************************************************************/\n\nimport { getEnvironmentData, isMainThread, setEnvironmentData, threadId as systemThreadId } from \"worker_threads\";\nimport { PubSub, ProcessPubSub } from \"./pubsub\";\nimport { Worker } from \"worker_threads\";\n\n/**\n * \"If I'm this, then do that\" -- raya (and also our threading model)\n * \n * Somehow, it took me forever to come up with this nice way of defining threads.\n * YavaScript is really dumb when it comes to initializing threads, a thread's initial\n * behavior must be defined at compile time. To get around this, we define the starting\n * states of each actor thread in one file, and select the initialization function at runtime.\n * \n * I haven't seen anyone do this, but I think it's a nice way to deal with multithreaded js programs.\n */\n// export type ActorSystemDef = () => (() => Actor[])[];\n// type CoordinatorMessage = {\n//   type: 'all_ready';\n// } | {\n//   type: 'worker_ready';\n//   index: number;\n// }\n// export function actorSystem(system: ActorSystemDef, systemFile: string, onInit: (id: RealmId) => void = () => {}) {\n//   const realmDefs = system();\n//   const coordinator = new StrictBroadcastChannel<CoordinatorMessage>('actor_system_coordinator');\n  \n//   if (isMainThread) {\n//     const readyMap = new Array<boolean>(realmDefs.length).fill(false);\n//     coordinator.onmessage = ({data: {type, index}}) => {\n//       if (realmDefs.length < 2) {\n//         ActorRealm.init(0);\n//         realmDefs[0]();\n//         return;\n//       }\n//       if (type === 'worker_ready') {\n//         readyMap[index] = true;\n//         if (readyMap.every(Boolean)) {\n//           console.log('all workers ready');\n//           coordinator.postMessage({ type: 'all_ready' });\n//           realmDefs[0]();\n//         }\n//       }\n//     }\n    \n//     ActorRealm.init(0);\n//     readyMap[0] = true;\n\n//     for (let index = 1; index < realmDefs.length; ++index) {\n//       setEnvironmentData('ACTOR_SYSTEM_INDEX', index);\n//       const worker = new Worker(systemFile);\n//       worker.postMessage({ type: 'spawn', index });\n//     }\n\n//   } else {\n//     const index = Number(getEnvironmentData('ACTOR_SYSTEM_INDEX'));\n//     ActorRealm.init(index);\n\n//     coordinator.onmessage = ({data: {type}}) => {\n//       if (type === 'all_ready') {\n//         if (!realmDefs[index]) {\n//           throw new Error('spawner not defined');\n//         } else {\n//           realmDefs[index]();\n//         }\n//       }\n//     }\n//     coordinator.postMessage({ type: 'worker_ready', index });\n//   }\n// }\n\n\nfunction threadsInit (initMain: () => void, initWorker: () => void) {\n  if (isMainThread) initMain();\n  else initWorker();\n}\n\nfunction ifMainDo<ReturnValue> (cb: () => ReturnValue) {\n  if (isMainThread) return cb();\n}\n\nfunction unlessMainDo<ReturnValue> (cb: () => ReturnValue) {\n  if (!isMainThread) return cb();\n}\n\nfunction isMainDef (defId: string | number) {\n  return defId === '0' || defId === 0 || defId === 'main';\n}\n\nfunction normalizeDef (defId: string, tDef: TDef<unknown>): TDefComplex<unknown> {\n  if (typeof tDef === 'function') {\n    return { name: defId, func: tDef, scale: 1 };\n  } else if (typeof tDef === 'object') {\n    return tDef;\n  } else {\n    throw new TypeError(`Invalid thread definition: ${typeof tDef}`);\n  }\n}\n\nfunction findDef<T> (defId: string, defs: TDefComplex<T>[]): TDefComplex<T> {\n  return defs.find((def) => def.name == defId);\n}\n\nfunction validateMainDef (mainDef: TDefComplex<unknown>) {\n  if (mainDef.scale != 1) {\n    throw new TypeError('Main Def must have scale of 1');\n  }\n}\n\nconst WORKER_INIT_ARGV_KEY = '_lthreads_worker_init_argv_'\ntype WorkerInitArgv = { name: string, workerId: WorkerId };\nfunction setWorkerInitArgv(argv: WorkerInitArgv) {\n  console.log('setting worker init argv', argv);\n  setEnvironmentData(WORKER_INIT_ARGV_KEY, argv);\n}\nfunction getWorkerInitArgv() {\n  const argv = getEnvironmentData(WORKER_INIT_ARGV_KEY) as WorkerInitArgv;\n  console.log('getting worker init argv', argv);\n  return argv;\n}\n\nfunction extractDefs (tDefs: ListedThreads<unknown> | NamedThreads<unknown>): [TDefFunc<unknown>, TDefComplex<unknown>[]] {\n  let mainDef: TDefFunc<unknown> = null;\n  const workerDefs: TDefComplex<unknown>[] = Object.entries(tDefs).reduce((acc, [defId, def]) => {\n    const normalized = normalizeDef(defId, def);\n\n    if (isMainDef(defId)) {\n      validateMainDef(normalized);\n      mainDef = normalized.func;\n      return acc;\n    } else {\n      return [...acc, normalizeDef(defId, def)];\n    }\n  }, [] as TDefComplex<unknown>[]);\n\n  if (!mainDef === null) {\n    mainDef = () => null;\n  }\n\n  return [mainDef, workerDefs];\n}\n\nexport function spawn(systemFile: string, name: string, workerId: WorkerId) {\n  ifMainDo(() => {\n    setWorkerInitArgv({ name, workerId });\n    const worker = new Worker(systemFile, {\n      execArgv: process.execArgv,\n      env: process.env,\n      workerData: { name, workerId }\n    });\n  });\n\n  unlessMainDo(() => {\n    // TODO: use global channel to signal main thread to spawn\n    throw new TypeError('threads can only be spawned from main (for now)');\n  })\n}\n\nfunction getWorkerId(name: string, index: string | number): WorkerId {\n  return `${name}:${index}`;\n}\n\n\nexport type GlobalChannelEvents = {\n  AllReady: {},\n  WorkerReady: { workerId: WorkerId }\n}\nexport interface ThreadOpts {\n  startBehavior: 'all' | 'each';\n  init?: (id: string) => void | Promise<void>;\n  pubsub?: PubSub<GlobalChannelEvents>;\n};\n\nconst defaultThreadOpts: ThreadOpts = {\n  startBehavior: 'all',\n  init: (id) => console.log(\"initializing\", id),\n  pubsub: new ProcessPubSub<GlobalChannelEvents>('_lthreads_global_')\n};\n\nexport type WorkerId = `${string}:${string}`;\nexport type TDefId = '0' | 'main' | string;\ntype TDefFunc<TDefReturn> = (id: WorkerId) => TDefReturn;\ntype TDefComplex<TDefReturn> = {func: TDefFunc<TDefReturn>, scale: number, name: string}\nexport type TDef<TDefReturn> = TDefFunc<TDefReturn> | TDefComplex<TDefReturn>;\ntype ListedThreads<TDefReturn> = TDef<TDefReturn>[]\ntype NamedThreads<TDefReturn> = {[key: string]: TDef<TDefReturn>}\n// export type ThreadsDefArray<TDefReturn> = () => (TDef<TDefReturn>)[];\n// export type ThreadsDefMap<TDefReturn> = () => {[key: string]: TDef<TDefReturn>}\nexport type ThreadsDef<TDefReturn> = () => ListedThreads<TDefReturn> | NamedThreads<TDefReturn>;\n// no need for constructors to be parameterized, no good way to define init params anyway.\n// do we even need TDefReturn????\n\nexport interface ThreadSystem {\n  __globalChannel: PubSub<GlobalChannelEvents>;\n  __workerStatuses: Map<WorkerId, 'Ready' | 'NotReady'>;\n  workerName: string;\n  workerId: WorkerId;\n  isMain: boolean;\n}\n\nexport function threads<TDefReturn = void> (\n  systemDef: ThreadsDef<TDefReturn>,\n  systemFile: string,\n  opts: ThreadOpts = defaultThreadOpts\n): ThreadSystem {\n  opts = { ...defaultThreadOpts, ...opts };\n  const globalChannel: PubSub<GlobalChannelEvents> = opts.pubsub;\n  const [mainDef, workerDefs] = extractDefs(systemDef())\n  const workerStatuses = new Map<WorkerId, 'Ready' | 'NotReady'>();\n  let _name: string;\n  let _workerId: WorkerId;\n  let defCalled = false;\n  const callDef = (def: TDefFunc<unknown>, id: WorkerId) => {\n    if (!defCalled) {\n      defCalled = true;\n      def(id);\n    }\n  }\n\n  const areAllWorkersReady = () => {\n    return !Array.from(workerStatuses.values()).some((status) => status != 'Ready');\n  }\n\n  ifMainDo(() => {\n    _name = 'main';\n    _workerId = getWorkerId(_name, 0);\n    const workerThreads = workerDefs.flatMap(({name, func, scale}) => {\n      return Array.from(Array(scale).keys()).map((index) => {\n        const threadId = getWorkerId(name, index);\n        const thread = spawn(systemFile, name, threadId);\n        workerStatuses.set(threadId, 'NotReady');\n        return thread;\n      });\n    });\n    console.log('worker threads', workerThreads, areAllWorkersReady());\n\n    globalChannel.sub('WorkerReady', ({ workerId }) => {\n      console.log('worker ready', workerId);\n      workerStatuses.set(workerId, 'Ready');\n      if (areAllWorkersReady()) {\n        callDef(mainDef, _workerId);\n        globalChannel.pub('AllReady', {});\n      }\n    })\n\n    if (workerThreads.length == 0) {\n      console.log('no worker threads, calling main def');\n      callDef(mainDef, _workerId);\n    } else if (opts.startBehavior == 'each') {\n      console.log('each worker thread, calling main def');\n      callDef(mainDef, _workerId);\n    } else if (opts.startBehavior == 'all') {\n      console.log('all worker threads, deferring main def');\n      globalChannel.sub('AllReady', () => {\n        callDef(mainDef, _workerId);\n      })\n    } else {\n      throw new Error(`Invalid start behavior: ${opts.startBehavior}`);\n    }\n  });\n\n  unlessMainDo(() => {\n    const { name, workerId } = getWorkerInitArgv();\n    _name = name;\n    _workerId = workerId;\n    const thisDef = workerDefs.find((def) => def.name == name);\n    if (!thisDef) {\n      throw new Error(`Thread definition not found: ${name}`);\n    }\n\n    if (opts.startBehavior == 'all') {\n      globalChannel.sub('AllReady', () => {\n        callDef(thisDef.func, workerId);\n      })\n      // await opts.init?.(workerId);\n      // TODO: add support for per-def initializers _cool_\n      globalChannel.pub('WorkerReady', { workerId });\n    } else if (opts.startBehavior == 'each') {\n      // await opts.init?.(workerId);\n      globalChannel.pub('WorkerReady', { workerId });\n      console.log('worker ready', workerId, thisDef);\n      callDef(thisDef.func, workerId);\n    } else {\n      throw new Error(`Invalid start behavior: ${opts.startBehavior}`);\n    }\n  });\n\n  return {\n    __globalChannel: globalChannel,\n    __workerStatuses: workerStatuses,\n    workerName: _name,\n    workerId: _workerId,\n    isMain: isMainThread\n  }\n}\n\n// export function multi(n: number, def: TDef)\n\n// This should return a value that I can use to safely send messages to threads.\n"],
  "mappings": "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",
  "names": ["import_worker_threads"]
}

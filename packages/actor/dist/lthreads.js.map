{
  "version": 3,
  "sources": ["../lthreads.ts"],
  "sourcesContent": ["/*****************************************************************************/\n/** Actor System */\n/*****************************************************************************/\n\nimport { getEnvironmentData, isMainThread, setEnvironmentData, threadId as systemThreadId } from \"worker_threads\";\nimport { PubSub, ProcessPubSub } from \"./pubsub\";\nimport { Worker } from \"worker_threads\";\n\n/**\n * \"If I'm this, then do that\" -- raya (and also our threading model)\n * \n * Somehow, it took me forever to come up with this nice way of defining threads.\n * YavaScript is really dumb when it comes to initializing threads, a thread's initial\n * behavior must be defined at compile time. To get around this, we define the starting\n * states of each actor thread in one file, and select the initialization function at runtime.\n * \n * I haven't seen anyone do this, but I think it's a nice way to deal with multithreaded js programs.\n */\n// export type ActorSystemDef = () => (() => Actor[])[];\n// type CoordinatorMessage = {\n//   type: 'all_ready';\n// } | {\n//   type: 'worker_ready';\n//   index: number;\n// }\n// export function actorSystem(system: ActorSystemDef, systemFile: string, onInit: (id: RealmId) => void = () => {}) {\n//   const realmDefs = system();\n//   const coordinator = new StrictBroadcastChannel<CoordinatorMessage>('actor_system_coordinator');\n  \n//   if (isMainThread) {\n//     const readyMap = new Array<boolean>(realmDefs.length).fill(false);\n//     coordinator.onmessage = ({data: {type, index}}) => {\n//       if (realmDefs.length < 2) {\n//         ActorRealm.init(0);\n//         realmDefs[0]();\n//         return;\n//       }\n//       if (type === 'worker_ready') {\n//         readyMap[index] = true;\n//         if (readyMap.every(Boolean)) {\n//           console.log('all workers ready');\n//           coordinator.postMessage({ type: 'all_ready' });\n//           realmDefs[0]();\n//         }\n//       }\n//     }\n    \n//     ActorRealm.init(0);\n//     readyMap[0] = true;\n\n//     for (let index = 1; index < realmDefs.length; ++index) {\n//       setEnvironmentData('ACTOR_SYSTEM_INDEX', index);\n//       const worker = new Worker(systemFile);\n//       worker.postMessage({ type: 'spawn', index });\n//     }\n\n//   } else {\n//     const index = Number(getEnvironmentData('ACTOR_SYSTEM_INDEX'));\n//     ActorRealm.init(index);\n\n//     coordinator.onmessage = ({data: {type}}) => {\n//       if (type === 'all_ready') {\n//         if (!realmDefs[index]) {\n//           throw new Error('spawner not defined');\n//         } else {\n//           realmDefs[index]();\n//         }\n//       }\n//     }\n//     coordinator.postMessage({ type: 'worker_ready', index });\n//   }\n// }\n\n\n// function ifMainDo<ReturnValue> (cb: () => ReturnValue) {\n//   if (isMainThread) return cb();\n// }\n\n// function unlessMainDo<ReturnValue> (cb: () => ReturnValue) {\n//   if (!isMainThread) return cb();\n// }\n\n\n/*****************************************************************************/\n/** System-Level Threading */\n/*****************************************************************************/\n\nfunction isMain() {\n  return isMainThread;\n}\n\nconst WORKER_INIT_ARGV_KEY = '_lthreads_worker_init_argv_'\ntype WorkerInitArgv = { name: string, workerId: WorkerId };\nfunction setWorkerInitArgv(argv: WorkerInitArgv) {\n  console.log('setting worker init argv', argv);\n  setEnvironmentData(WORKER_INIT_ARGV_KEY, argv);\n}\nfunction getWorkerInitArgv() {\n  const argv = getEnvironmentData(WORKER_INIT_ARGV_KEY) as WorkerInitArgv;\n  console.log('getting worker init argv', argv);\n  return argv;\n}\n\nexport function spawn(systemFile: string, name: string, workerId: WorkerId): Worker {\n  if (!isMain()) {\n    throw new TypeError('threads can only be spawned from main (for now)');\n  }\n\n  setWorkerInitArgv({ name, workerId });\n  const worker = new Worker(systemFile, {\n    execArgv: process.execArgv,\n    env: process.env,\n    workerData: { name, workerId }\n  });\n  return worker;\n}\n\n/*****************************************************************************/\n/** Thread Definition Utilities */\n/*****************************************************************************/\n\nfunction isMainDef (defId: string | number) {\n  return defId === '0' || defId === 0 || defId === 'main';\n}\n\nfunction normalizeDef (defId: string, tDef: TDef): TDefComplex {\n  if (typeof tDef === 'function') {\n    return { name: defId, func: tDef, scale: 1 };\n  } else if (typeof tDef === 'object') {\n    return tDef;\n  } else {\n    throw new TypeError(`Invalid thread definition: ${typeof tDef}`);\n  }\n}\n\nfunction validateMainDef (mainDef: TDefComplex) {\n  if (mainDef.scale != 1) {\n    throw new TypeError('Main Def must have scale of 1');\n  }\n}\n\nfunction extractDefs (tDefs: ListedThreads | NamedThreads): [TDefFunc, TDefComplex[]] {\n  let mainDef: TDefFunc = null;\n  const workerDefs: TDefComplex[] = Object.entries(tDefs).reduce((acc, [defId, def]) => {\n    const normalized = normalizeDef(defId, def);\n\n    if (isMainDef(defId)) {\n      validateMainDef(normalized);\n      mainDef = normalized.func;\n      return acc;\n    } else {\n      return [...acc, normalizeDef(defId, def)];\n    }\n  }, [] as TDefComplex[]);\n\n  if (!mainDef === null) {\n    mainDef = () => null;\n  }\n\n  return [mainDef, workerDefs];\n}\n\nfunction getWorkerId(name: string, index: string | number): WorkerId {\n  return `${name}:${index}`;\n}\n\n/*****************************************************************************/\n/** Thread System */\n/*****************************************************************************/\n\nexport type WorkerId = `${string}:${string}`;\nexport type TDefId = '0' | 'main' | string;\ntype TDefFunc = (id: WorkerId) => void | Promise<void>;\ntype TDefComplex = {func: TDefFunc, scale: number, name: string}\nexport type TDef = TDefFunc | TDefComplex;\ntype ListedThreads = TDef[]\ntype NamedThreads = {[key: string]: TDef}\nexport type ThreadsDef = () => ListedThreads | NamedThreads;\n\n\nexport type GlobalChannelEvents = {\n  AllReady: {},\n  WorkerReady: { workerId: WorkerId },\n  WorkerExit: { workerId: WorkerId, code: number },\n  WorkerError: { workerId: WorkerId, error: any }\n}\n\n/*****************************************************************************/\n/** Thread System Configuration */\n/*****************************************************************************/\n\ntype WorkerErrorBehavior = 'Restart' | 'Ignore' | 'Fatal';\nexport interface ThreadOpts {\n  startBehavior: 'all' | 'each';\n  init?: (id: string) => void | Promise<void>;\n  pubsub?: PubSub<GlobalChannelEvents>;\n  onWorkerExit?: (workerId: WorkerId, code: number) => void;\n  onWorkerError?: WorkerErrorBehavior;\n  maxRetries?: number;\n};\n\nconst defaultThreadOpts: ThreadOpts = {\n  startBehavior: 'all',\n  init: (id) => console.log(\"initializing\", id),\n  pubsub: new ProcessPubSub<GlobalChannelEvents>('_lthreads_global_'),\n  onWorkerExit: (workerId, code) => console.log(`Worker ${workerId} exited with code ${code}`),\n  onWorkerError: 'Restart',\n  maxRetries: 3\n};\n\n/*****************************************************************************/\n/** Thread System Implementation */\n/*****************************************************************************/\n\n// export type ThreadsDefArray<TDefReturn> = () => (TDef<TDefReturn>)[];\n// export type ThreadsDefMap<TDefReturn> = () => {[key: string]: TDef<TDefReturn>}\n\nexport interface ThreadSystem {\n  __globalChannel: PubSub<GlobalChannelEvents>;\n  __workerStatuses: Map<WorkerId, 'Ready' | 'NotReady' | 'Terminated'>;\n  workerName: string;\n  workerId: WorkerId;\n  isMain: boolean;\n}\n\nexport function threads (\n  systemDef: ThreadsDef,\n  systemFile: string,\n  opts: ThreadOpts = defaultThreadOpts\n): ThreadSystem {\n  opts = { ...defaultThreadOpts, ...opts };\n  const globalChannel: PubSub<GlobalChannelEvents> = opts.pubsub;\n  const [mainDef, workerDefs] = extractDefs(systemDef())\n  const workerStatuses = new Map<WorkerId, 'Ready' | 'NotReady' | 'Terminated'>();\n  let _name: string;\n  let _workerId: WorkerId;\n  let defCalled = false;\n  const callDef = async (def: TDefFunc, id: WorkerId) => {\n    if (!defCalled) {\n      defCalled = true;\n      await def(id);\n    }\n  }\n\n  const areAllWorkersReady = () => {\n    return !Array.from(workerStatuses.values()).some((status) => status === 'NotReady');\n  }\n\n  const handleThread = (thread: Worker, threadId: WorkerId, name: string, retries: number = 0) => {\n    thread.on('exit', (code) => {\n      console.log(`Worker ${threadId} exited with code ${code}`);\n      workerStatuses.set(threadId, 'Terminated');\n      globalChannel.pub('WorkerExit', { workerId: threadId, code });\n      opts.onWorkerExit?.(threadId, code);\n    });\n    \n    thread.on('error', (error) => {\n      console.error(`Worker ${threadId} error:`, error);\n      workerStatuses.set(threadId, 'Terminated');\n      globalChannel.pub('WorkerError', { workerId: threadId, error });\n      if (opts.onWorkerError == 'Restart') {\n        if (retries >= opts.maxRetries) {\n          console.log(`Worker ${threadId} error: ${error}, max retries reached`);\n        } else {\n          console.log(`Worker ${threadId} error: ${error}, restarting`);\n          const newThread = spawn(systemFile, name, threadId);\n          if (newThread) {\n            handleThread(newThread, threadId, name, retries + 1);\n          }\n        }\n      } else if (opts.onWorkerError == 'Ignore') {\n        workerStatuses.set(threadId, 'Terminated');\n        globalChannel.pub('WorkerExit', { workerId: threadId, code: 0 });\n        console.log(`Worker ${threadId} error: ${error}, ignoring`);\n        // do nothing\n      } else if (opts.onWorkerError == 'Fatal') {\n        workerStatuses.set(threadId, 'Terminated');\n        globalChannel.pub('WorkerExit', { workerId: threadId, code: 1 });\n        console.log(`Worker ${threadId} error: ${error}, fatal`);\n        throw error;\n      }\n    });\n  }\n\n  if (isMain()) {\n    _name = 'main';\n    _workerId = getWorkerId(_name, 0);\n    const workerThreads = workerDefs.flatMap(({name, func, scale}) => {\n      return Array.from(Array(scale).keys()).map((index) => {\n        const threadId = getWorkerId(name, index);\n        const thread = spawn(systemFile, name, threadId);\n        workerStatuses.set(threadId, 'NotReady');\n        \n        // Add event listeners for worker lifecycle\n        if (thread) {\n          handleThread(thread, threadId, name);\n        }\n        \n        return { threadId, thread };\n      });\n    });\n    console.log('worker threads', workerThreads.map(w => w.threadId), areAllWorkersReady());\n\n    globalChannel.sub('WorkerReady', ({ workerId }) => {\n      console.log('worker ready', workerId);\n      workerStatuses.set(workerId, 'Ready');\n      if (areAllWorkersReady()) {\n        callDef(mainDef, _workerId);\n        globalChannel.pub('AllReady', {});\n      }\n    })\n\n    if (workerThreads.length == 0) {\n      console.log('no worker threads, calling main def');\n      callDef(mainDef, _workerId);\n    }\n\n    if (opts.startBehavior == 'each') {\n      console.log('each worker thread, calling main def');\n      callDef(mainDef, _workerId);\n    } else if (opts.startBehavior == 'all') {\n      console.log('all worker threads, deferring main def');\n      globalChannel.sub('AllReady', () => {\n        callDef(mainDef, _workerId);\n      })\n    } else {\n      throw new Error(`Invalid start behavior: ${opts.startBehavior}`);\n    }\n  } else {\n    const { name, workerId } = getWorkerInitArgv();\n    _name = name;\n    _workerId = workerId;\n    const thisDef = workerDefs.find((def) => def.name == name);\n    if (!thisDef) {\n      throw new Error(`Thread definition not found: ${name}`);\n    }\n\n    if (opts.startBehavior == 'all') {\n      globalChannel.sub('AllReady', () => {\n        callDef(thisDef.func, workerId);\n      })\n      // await opts.init?.(workerId);\n      // TODO: add support for per-def initializers _cool_\n      globalChannel.pub('WorkerReady', { workerId });\n    } else if (opts.startBehavior == 'each') {\n      // await opts.init?.(workerId);\n      globalChannel.pub('WorkerReady', { workerId });\n      console.log('worker ready', workerId, thisDef);\n      callDef(thisDef.func, workerId);\n    } else {\n      throw new Error(`Invalid start behavior: ${opts.startBehavior}`);\n    }\n  }\n\n  return {\n    __globalChannel: globalChannel,\n    __workerStatuses: workerStatuses,\n    workerName: _name,\n    workerId: _workerId,\n    isMain: isMainThread\n  }\n}\n\n// export function multi(n: number, def: TDef)\n\n// This should return a value that I can use to safely send messages to threads.\n"],
  "mappings": "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",
  "names": ["import_worker_threads"]
}
